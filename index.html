<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>guerrillagrotto.space</title>
  <!-- Favicon: empty circle with a plus inside -->
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml;utf8,
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
      <circle cx="32" cy="32" r="27" fill="none" stroke="black" stroke-width="4"/>
      <path d="M32 16v32M16 32h32" stroke="black" stroke-width="4" fill="none" stroke-linecap="square"/>
    </svg>' />
  <style>
    :root{
      --bg: #000;          /* base background */
      --fg: #fff;          /* base foreground (text + lines) */
      --muted: #999;
      --stroke: 1px;       /* global stroke width (updated) */
      --cursor-stroke: 1.6px; /* custom cursor stroke */
      --plus-size: 16px;       /* custom cursor plus arm length */
      --ui-scale: 78vmin;  /* size of the main framed SVG */
      --phrase-gap: 12ch;  /* large spacing between repeated phrases */
      --hover-delta: 18%;  /* how much lighter/darker on hover */
      --text-size: 12px;   /* unified size for banner + interior text */
    }

    /* Inverted ("Guerrilla") mode */
    body.inverted{
      --bg:#fff;
      --fg:#000;
    }

    /* Base reset */
    html,body{height:100%;}
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      cursor: none; /* no stock cursor */
      overflow:hidden; /* keep the layout tight */
    }

    /* ==== Floating bottom marquee ==== */
    .marquee-wrap{
      position: fixed;
      left: 0; right: 0; bottom: 0; /* bottom of screen */
      pointer-events: none; /* default: no hover except specific words */
      user-select: none;
      padding-bottom: 8px; /* float slightly above bottom edge */
    }
    .marquee{ 
      display: flex; 
      white-space: nowrap; 
      gap: var(--phrase-gap); /* large gap between phrases */
      will-change: transform;
      animation: scroll 18s linear infinite;
      font-size: var(--text-size);
      letter-spacing: 0.02em;
    }
    @keyframes scroll{ from{transform: translateX(0);} to{transform: translateX(-50%);} }

    .marquee .chunk{ display:flex; gap: var(--phrase-gap); }
    .phrase{ pointer-events:none; }
    .phrase .grotto{ pointer-events:auto; transition: filter .15s ease; }
    .marquee.paused{ animation-play-state: paused; }

    /* Hover affordance: slightly darker or lighter */
    .hover-affordance{ filter: brightness(calc(100% - var(--hover-delta))); }
    body.inverted .hover-affordance{ filter: brightness(calc(100% + var(--hover-delta))); }

    /* ==== Centered framed composition (SVG scales evenly) ==== */
    .stage{ position: absolute; inset: 0; display: grid; place-items: center; }
    .frame{ width: min(var(--ui-scale), 92vw); height: auto; max-height: 72vh; aspect-ratio: 4 / 3; display: block; }

    /* Rotating text inside right circle */
    .rotateCCW{ animation: rotateCCW 16s linear infinite; transform-origin: 50% 50%; }
    @keyframes rotateCCW{ from{ transform: rotate(0deg);} to{ transform: rotate(-360deg);} }

    /* Plus targets turn red when overlapped */
    .plus-hit.ok{ color: #d00; }

    /* ====== Custom PLUS cursor (mix-blend-difference to invert underlay) ====== */
    .cursor-plus{ position: fixed; left:0; top:0; width:0; height:0; z-index: 1000; pointer-events: none; mix-blend-mode: difference; }
    .cursor-plus::before, .cursor-plus::after{ content:""; position:absolute; left:0; top:0; border: var(--cursor-stroke) solid var(--fg); width: calc(var(--plus-size)*2); height: 0; transform: translate(-50%, -50%); }
    .cursor-plus::after{ width:0; height: calc(var(--plus-size)*2); }
  </style>
</head>
<body>
  <div id="cursor" class="cursor-plus" aria-hidden="true"></div>

  <!-- Centered SVG frame (rectangle + 2 circles + plus signs) -->
  <main class="stage">
    <svg id="ui" class="frame" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg" aria-labelledby="title desc">
      <title id="title">guerrillagrotto composition</title>
      <desc id="desc">Rectangle framing two circles. Left circle has draggable plus; right circle has static plus and rotating issue text. Drag allowed in Guerrilla mode. Colors invert when toggling mode.</desc>

      <!-- Shared paint -->
      <defs>
        <!-- text-on-a-circle path (slightly inset so it doesn't touch the line) -->
        <path id="ringPath" d="M 533.33,300 m -110,0 a 110,110 0 1,1 220,0 a 110,110 0 1,1 -220,0" />
      </defs>

      <!-- Frame rectangle (stroke matches circles and pluses) -->
      <g id="composition" stroke="currentColor" fill="none" stroke-width="1">
        <rect id="frameRect" x="120" y="120" width="560" height="360" rx="2"/>

        <!-- Circles (same size, centered vertically, evenly spaced horizontally) -->
        <circle id="leftCircle" cx="266.67" cy="300" r="120" />
        <circle id="rightCircle" cx="533.33" cy="300" r="120" />

        <!-- Rotating issue text inside right circle, counterclockwise; size = banner size -->
        <g class="rotateCCW">
          <text id="issue" fill="currentColor" style="font-size: var(--text-size);" letter-spacing="0.08em">
            <textPath href="#ringPath" startOffset="0%">ISSUE 001 — 12/12</textPath>
          </text>
        </g>

        <!-- Larger plus signs INSIDE circles (same thin stroke). Slightly toward center, still lower-right quadrant. -->
        <!-- RIGHT (static) target -->
        <g id="rightPlus" class="plus-hit" transform="translate(573.33, 340)">
          <line x1="-24" y1="0" x2="24" y2="0" />
          <line x1="0" y1="-24" x2="0" y2="24" />
        </g>

        <!-- LEFT (draggable) target -->
        <g id="leftPlus" class="plus-hit" transform="translate(306.67, 340)">
          <line x1="-24" y1="0" x2="24" y2="0" />
          <line x1="0" y1="-24" x2="0" y2="24" />
        </g>
      </g>
    </svg>
  </main>

  <!-- Endless loop banner (bottom) with interaction on the word "grotto" only -->
  <div class="marquee-wrap">
    <div id="marquee" class="marquee" aria-hidden="true"></div>
  </div>

  <script>
    /* ================= Custom PLUS cursor ================= */
    const cursor = document.getElementById('cursor');
    const setCursorPos = (e) => { cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`; };
    window.addEventListener('mousemove', setCursorPos, {passive:true});
    window.addEventListener('touchmove', (e)=>{
      if(e.touches && e.touches[0]) setCursorPos({clientX:e.touches[0].clientX, clientY:e.touches[0].clientY});
    }, {passive:true});

    /* ================= Marquee builder (endless, bottom) ================= */
    const marquee = document.getElementById('marquee');

    function buildMarquee(){
      const one = document.createElement('div'); one.className = 'chunk';
      for (let i=0;i<30;i++) { // enough to overflow for seamless loop
        const phrase = document.createElement('span');
        phrase.className = 'phrase';
        phrase.appendChild(document.createTextNode('Welcome to the '));
        const grot = document.createElement('span');
        grot.textContent = 'grotto';
        grot.className = 'grotto';
        phrase.appendChild(grot);
        one.appendChild(phrase);
      }
      const two = one.cloneNode(true);
      marquee.appendChild(one);
      marquee.appendChild(two);
    }
    buildMarquee();

    // Hover on the word "grotto" pauses loop and shows affordance
    marquee.addEventListener('mouseover', (e)=>{
      if(e.target.classList.contains('grotto')){
        marquee.classList.add('paused');
        e.target.classList.add('hover-affordance');
      }
    });
    marquee.addEventListener('mouseout', (e)=>{
      if(e.target.classList.contains('grotto')){
        marquee.classList.remove('paused');
        e.target.classList.remove('hover-affordance');
      }
    });

    /* ================= Mode toggle via clicking any "grotto" word ================= */
    let guerrillaMode = false; // drag only allowed in this mode
    function randomChar(){
      const chars = '!<>-_\\/[]{}—=+*^?#________';
      return chars[Math.floor(Math.random()*chars.length)];
    }
    function glitchSwap(node, toText){
      const from = node.textContent;
      const max = Math.max(from.length, toText.length);
      let i=0;
      const timer = setInterval(()=>{
        const out = [];
        for(let k=0;k<max;k++){
          const targetCh = (k < toText.length) ? toText[k] : '';
          if(k < i){ out.push(targetCh); }
          else { out.push(randomChar()); }
        }
        node.textContent = out.join('');
        i++;
        if(i>max){ clearInterval(timer); node.textContent = toText; }
      }, 18);
    }

    function toggleMode(){
      guerrillaMode = !guerrillaMode;
      document.body.classList.toggle('inverted', guerrillaMode);
      // swap all instances of grotto <-> Gurilla with glitch
      document.querySelectorAll('.grotto').forEach(el=>{
        const to = guerrillaMode ? 'Gurilla' : 'grotto';
        glitchSwap(el, to);
      });
    }

    marquee.addEventListener('click', (e)=>{
      if(e.target.classList.contains('grotto')){
        toggleMode();
      }
    });

    /* ================= Draggable left plus, target overlap detection ================= */
    const svg = document.getElementById('ui');
    const leftPlus = document.getElementById('leftPlus');
    const rightPlus = document.getElementById('rightPlus');

    function svgPointFromEvent(evt){
      const pt = svg.createSVGPoint();
      const ctm = svg.getScreenCTM();
      const x = (evt.touches?evt.touches[0].clientX:evt.clientX);
      const y = (evt.touches?evt.touches[0].clientY:evt.clientY);
      pt.x = x; pt.y = y; return pt.matrixTransform(ctm.inverse());
    }

    let dragging = false;
    function startDrag(evt){ if(!guerrillaMode) return; dragging = true; evt.preventDefault(); }
    function endDrag(){ dragging = false; }
    function onDrag(evt){
      if(!dragging || !guerrillaMode) return; 
      const p = svgPointFromEvent(evt);
      leftPlus.setAttribute('transform', `translate(${p.x}, ${p.y})`);
      checkOverlap();
    }

    leftPlus.addEventListener('mousedown', startDrag);
    window.addEventListener('mouseup', endDrag);
    leftPlus.addEventListener('touchstart', startDrag, {passive:false});
    window.addEventListener('touchend', endDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('touchmove', onDrag, {passive:false});

    function centerOf(g){ const m = g.getCTM(); return { x: m.e, y: m.f }; }
    function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    let overlapReady = false;
    function checkOverlap(){
      const a = centerOf(leftPlus), b = centerOf(rightPlus);
      const d = distance(a,b);
      const threshold = 24; // match larger plus size arms
      const ok = d < threshold;
      overlapReady = ok;
      leftPlus.classList.toggle('ok', ok);
      rightPlus.classList.toggle('ok', ok);
    }

    svg.addEventListener('click', (e)=>{
      if(overlapReady){ window.location.href = 'secret.html'; }
    });

    /* ================= Accessibility: keyboard fallback ================= */
    document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='g'){ toggleMode(); } });
  </script>
</body>
</html>
