<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>guerrillagrotto.space</title>
  <!-- Favicon: empty circle with a plus inside -->
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml;utf8,
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
      <circle cx="32" cy="32" r="27" fill="none" stroke="black" stroke-width="4"/>
      <path d="M32 16v32M16 32h32" stroke="black" stroke-width="4" fill="none" stroke-linecap="square"/>
    </svg>' />
  <style>
    :root{
      --bg: #000;          /* base background */
      --fg: #fff;          /* base foreground (text + lines) */
      --muted: #999;
      --stroke: 1px;       /* global stroke width */
      --cursor-stroke: 1.6px; /* custom cursor stroke */
      --plus-size: 16px;       /* custom cursor plus arm length */
      --ui-scale: 78vmin;  /* size of the main framed SVG */
      --phrase-gap: 12ch;  /* large spacing between repeated phrases */
      --hover-delta: 18%;  /* how much lighter/darker on hover */
      --text-size: 12px;   /* unified size for banner + interior text */
    }

    /* Inverted ("Guerrilla") mode */
    body.inverted{
      --bg:#fff;
      --fg:#000;
    }

    /* Base reset */
    html,body{height:100%;}
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      cursor: none; /* hide default cursor on body */
      overflow:hidden; /* keep the layout tight */
    }
    /* Ensure no default cursor anywhere */
    body *{ cursor:none; }

    /* ==== Floating bottom marquee ==== */
    .marquee-wrap{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      user-select: none;
      padding-bottom: 8px;
    }
    .marquee{ 
      display: flex; 
      white-space: nowrap; 
      gap: var(--phrase-gap);
      will-change: transform;
      animation: scroll 18s linear infinite;
      font-size: var(--text-size);
      letter-spacing: 0.02em;
    }
    @keyframes scroll{ from{transform: translateX(0);} to{transform: translateX(-50%);} }

    .marquee .chunk{ display:flex; gap: var(--phrase-gap); }
    .phrase{ pointer-events:auto; }
    .phrase .grotto{ pointer-events:auto; transition: filter .15s ease; }

    /* make "grotto" red */
    .marquee .grotto{
      color:#ff3333;
    }

    .marquee.paused{ animation-play-state: paused; }

    /* Hover affordance: slightly darker or lighter */
    .hover-affordance{ filter: brightness(calc(100% - var(--hover-delta))); }
    body.inverted .hover-affordance{ filter: brightness(calc(100% + var(--hover-delta))); }

    /* ==== Centered framed composition (SVG scales evenly) ==== */
    .stage{ position: absolute; inset: 0; display: grid; place-items: center; }
    .frame{ width: min(var(--ui-scale), 92vw); height: auto; max-height: 72vh; aspect-ratio: 4 / 3; display: block; }

    /* Plus targets turn red when overlapped */
    .plus-hit.ok{ color: #d00; }

    /* ====== Custom PLUS cursor (fixed for white background) ====== */
    .cursor-plus{
      position: fixed;
      left:0;
      top:0;
      width:0;
      height:0;
      z-index: 1000;
      pointer-events: none;
      /* no blend mode: always visible; subtle shadow against bg */
      filter: drop-shadow(0 0 1px var(--bg));
    }
    .cursor-plus::before, .cursor-plus::after{
      content:"";
      position:absolute;
      left:0;
      top:0;
      border: var(--cursor-stroke) solid currentColor;
      width: calc(var(--plus-size)*2);
      height: 0;
      transform: translate(-50%, -50%);
    }
    .cursor-plus::after{
      width:0;
      height: calc(var(--plus-size)*2);
    }

    /* ====== SHOP BUTTON (left plus) highlighting – both modes ====== */
    #leftPlus{
      stroke:#ff3333;
      color:#ff3333;
      filter: drop-shadow(0 0 4px rgba(255,0,0,0.9));
      animation: shopPulse 1.4s ease-in-out infinite alternate;
      cursor:none;
    }
    @keyframes shopPulse{
      0%{
        filter: drop-shadow(0 0 2px rgba(255,0,0,0.6));
      }
      100%{
        filter: drop-shadow(0 0 8px rgba(255,0,0,1));
      }
    }
    /* extra feedback when cursor is over the hit area */
    #leftPlus.hovered{
      animation-duration: 0.7s;
      filter: drop-shadow(0 0 12px rgba(255,0,0,1));
    }

    /* Rotating issue text in right circle: make red */
    #issue{
      fill:#ff3333;
    }
  </style>
</head>
<body>
  <div id="cursor" class="cursor-plus" aria-hidden="true"></div>

  <!-- Centered SVG frame (rectangle + 2 circles + plus signs) -->
  <main class="stage">
    <svg id="ui" class="frame" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg" aria-labelledby="title desc">
      <title id="title">guerrillagrotto composition</title>
      <desc id="desc">Rectangle framing two circles. Left circle has draggable plus; right circle has static plus and rotating issue text. Drag allowed in Guerrilla mode. Colors invert when toggling mode.</desc>

      <!-- Shared paint -->
      <defs>
        <!-- text-on-a-circle path (slightly inset so it doesn't touch the line) -->
        <path id="ringPath" d="M 533.33,300 m -110,0 a 110,110 0 1,1 220,0 a 110,110 0 1,1 -220,0" />
      </defs>

      <!-- Frame rectangle (stroke matches circles and pluses) -->
      <g id="composition" stroke="currentColor" fill="none" stroke-width="var(--stroke)">
        <rect id="frameRect" x="120" y="120" width="560" height="360" rx="2"/>

        <!-- Circles (same size, centered vertically, evenly spaced horizontally) -->
        <circle id="leftCircle" cx="266.67" cy="300" r="120" />
        <circle id="rightCircle" cx="533.33" cy="300" r="120" />

        <!-- Rotating issue text along interior radius of right circle -->
        <text id="issue" style="font-size: var(--text-size);" letter-spacing="0.08em">
          <textPath id="issuePath" href="#ringPath" startOffset="0%">
            ISSUE 001 — 12/18 — ISSUE 001 — 12/18 — ISSUE 001 — 12/18 —
            <animate attributeName="startOffset" from="0%" to="100%" dur="16s" repeatCount="indefinite" />
          </textPath>
        </text>

        <!-- RIGHT (static) target -->
        <g id="rightPlus" class="plus-hit" transform="translate(573.33, 340)">
          <line x1="-24" y1="0" x2="24" y2="0" />
          <line x1="0" y1="-24" x2="0" y2="24" />
        </g>

        <!-- LEFT (shop link + draggable in guerrilla mode) -->
        <g id="leftPlus" class="plus-hit" transform="translate(306.67, 340)">
          <!-- bigger invisible hit area to make clicking easier -->
          <circle r="40" fill="transparent" />
          <line x1="-24" y1="0" x2="24" y2="0" />
          <line x1="0" y1="-24" x2="0" y2="24" />
        </g>
      </g>
    </svg>
  </main>

  <!-- Endless loop banner (bottom) with interaction on the word "grotto" only -->
  <div class="marquee-wrap">
    <div id="marquee" class="marquee" aria-hidden="true"></div>
  </div>

  <script>
    /* ================= Custom PLUS cursor ================= */
    const cursor = document.getElementById('cursor');
    const setCursorPos = (e) => { cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`; };
    window.addEventListener('mousemove', setCursorPos, {passive:true});
    window.addEventListener('touchmove', (e)=>{
      if(e.touches && e.touches[0]) setCursorPos({clientX:e.touches[0].clientX, clientY:e.touches[0].clientY});
    }, {passive:true});

    /* ================= Marquee builder (endless, bottom) ================= */
    const marquee = document.getElementById('marquee');

    function buildMarquee(){
      const one = document.createElement('div'); one.className = 'chunk';
      for (let i=0;i<30;i++) { // enough to overflow for seamless loop
        const phrase = document.createElement('span');
        phrase.className = 'phrase';
        phrase.appendChild(document.createTextNode('Welcome to the '));
        const grot = document.createElement('span');
        grot.textContent = 'grotto';
        grot.className = 'grotto';
        phrase.appendChild(grot);
        one.appendChild(phrase);
      }
      const two = one.cloneNode(true);
      marquee.appendChild(one);
      marquee.appendChild(two);
    }
    buildMarquee();

    // Hover anywhere on banner pauses loop; hover on "grotto" also gives affordance
    marquee.addEventListener('mouseover', (e)=>{
      marquee.classList.add('paused');
      if(e.target.classList.contains('grotto')){
        e.target.classList.add('hover-affordance');
      }
    });
    marquee.addEventListener('mouseout', (e)=>{
      marquee.classList.remove('paused');
      if(e.target.classList.contains('grotto')){
        e.target.classList.remove('hover-affordance');
      }
    });

    /* ================= Mode toggle via clicking any "grotto" word ================= */
    let guerrillaMode = false; // drag only allowed in this mode
    function randomChar(){
      const chars = '!<>-_\\/[]{}—=+*^?#________';
      return chars[Math.floor(Math.random()*chars.length)];
    }
    function glitchSwap(node, toText){
      const from = node.textContent;
      const max = Math.max(from.length, toText.length);
      let i=0;
      const timer = setInterval(()=>{
        const out = [];
        for(let k=0;k<max;k++){
          const targetCh = (k < toText.length) ? toText[k] : '';
          if(k < i){ out.push(targetCh); }
          else { out.push(randomChar()); }
        }
        node.textContent = out.join('');
        i++;
        if(i>max){ clearInterval(timer); node.textContent = toText; }
      }, 18);
    }

    function toggleMode(){
      guerrillaMode = !guerrillaMode;
      document.body.classList.toggle('inverted', guerrillaMode);
      // swap all instances of grotto <-> guerrilla grotto with glitch
      document.querySelectorAll('.grotto').forEach(el=>{
        const to = guerrillaMode ? 'guerrilla grotto' : 'grotto';
        glitchSwap(el, to);
      });
    }

    marquee.addEventListener('click', (e)=>{
      if(e.target.classList.contains('grotto')){
        toggleMode();
      }
    });

    /* ================= Draggable left plus, target overlap detection ================= */
    const svg = document.getElementById('ui');
    const leftPlus = document.getElementById('leftPlus');
    const rightPlus = document.getElementById('rightPlus');

    function svgPointFromEvent(evt){
      const pt = svg.createSVGPoint();
      const ctm = svg.getScreenCTM();
      const x = (evt.touches?evt.touches[0].clientX:evt.clientX);
      const y = (evt.touches?evt.touches[0].clientY:evt.clientY);
      pt.x = x; pt.y = y; return pt.matrixTransform(ctm.inverse());
    }

    let dragging = false;
    function startDrag(evt){
      if(!guerrillaMode) return;
      dragging = true;
      evt.preventDefault();
    }
    function endDrag(){ dragging = false; }
    function onDrag(evt){
      if(!dragging || !guerrillaMode) return; 
      const p = svgPointFromEvent(evt);
      leftPlus.setAttribute('transform', `translate(${p.x}, ${p.y})`);
      checkOverlap();
    }

    leftPlus.addEventListener('mousedown', startDrag);
    window.addEventListener('mouseup', endDrag);
    leftPlus.addEventListener('touchstart', startDrag, {passive:false});
    window.addEventListener('touchend', endDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('touchmove', onDrag, {passive:false});

    function centerOf(g){ const m = g.getCTM(); return { x: m.e, y: m.f }; }
    function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    let overlapReady = false;
    function checkOverlap(){
      const a = centerOf(leftPlus), b = centerOf(rightPlus);
      const d = distance(a,b);
      const threshold = 24; // match larger plus size arms
      const ok = d < threshold;
      overlapReady = ok;
      leftPlus.classList.toggle('ok', ok);
      rightPlus.classList.toggle('ok', ok);
    }

    svg.addEventListener('click', (e)=>{
      if(overlapReady){ window.location.href = 'secret.html'; }
    });

    // Left plus = shop link in BOTH modes
    leftPlus.addEventListener('click', (e)=>{
      // prevent drag-click from also firing secret logic
      if(dragging) return;
      window.location.href = 'shop.html';
    });

    // hover feedback when cursor overlaps hit area
    leftPlus.addEventListener('mouseenter', ()=>{
      leftPlus.classList.add('hovered');
    });
    leftPlus.addEventListener('mouseleave', ()=>{
      leftPlus.classList.remove('hovered');
    });

    /* ================= Accessibility: keyboard fallback ================= */
    document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='g'){ toggleMode(); } });
  </script>
</body>
</html>
